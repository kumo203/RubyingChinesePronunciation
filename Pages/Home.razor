@page "/"
@using _pinyin_ruby.Services
@using Microsoft.JSInterop
@inject IPinyinService PinyinService
@inject IHistoryService HistoryService
@inject IJSRuntime JSRuntime

<PageTitle>Pinyin Ruby Tool</PageTitle>

<div class="container main-container">
    <div class="header-section text-center my-4">
        <h1 class="display-4">Pinyin Ruby Tool</h1>
        <p class="lead">Adding Pinyin/Zhuyin ruby to Chinese text instantly.</p>
    </div>
    
    <div class="input-section">
        <div class="form-group">
            <label for="TextInput" class="form-label fw-bold">Input Chinese Text:</label>
            <textarea id="TextInput" @bind="inputText" class="form-control" rows="6" placeholder="Enter Chinese characters here (e.g., 你好世界)..."></textarea>
        </div>
        <div class="actions mt-3 text-end">
            <button class="btn btn-primary btn-lg" @onclick="ConvertText">
                <span class="oi oi-transfer me-2"></span>Convert
            </button>
        </div>
    </div>

    @if (rubyTokens != null)
    {
        <div class="output-section mt-5 fade-in">
            <div class="card mb-4">
                <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                    <h3 class="card-title h5 mb-0">Result</h3>
                    <div class="btn-group btn-group-sm" role="group">
                        <input type="radio" class="btn-check" name="rubyMode" id="modePinyin" value="pinyin" @onchange="ChangeMode" checked />
                        <label class="btn btn-outline-light" for="modePinyin">Pinyin</label>
                        
                        <input type="radio" class="btn-check" name="rubyMode" id="modeZhuyin" value="zhuyin" @onchange="ChangeMode" />
                        <label class="btn btn-outline-light" for="modeZhuyin">Zhuyin (注音)</label>
                    </div>
                </div>
                <div class="card-body">
                    <div class="preview-boxes-container d-flex flex-column gap-2" tabindex="0" @onkeydown="HandleKeyDown" @onkeydown:preventDefault="true" @ref="previewBox">
                        @{
                            var lines = GetTokenLines();
                        }
                        @foreach (var line in lines)
                        {
                            <div class="preview-box p-3 border rounded bg-light">
                                <div class="ruby-line">
                                    @foreach (var item in line)
                                    {
                                        var index = item.Index;
                                        var token = item.Token;
                                        if (token.IsRuby)
                                        {
                                            var rubyText = rubyMode == "zhuyin" ? token.Zhuyin : token.Pinyin;
                                            <ruby class="@(GetClass(index))" @onclick="() => SelectToken(index)">
                                                @token.Text<rt>@rubyText</rt>
                                            </ruby>
                                        }
                                        else
                                        {
                                            <span class="plain-text">@token.Text</span>
                                        }
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }

    <!-- History Pane -->
    <div class="card mt-4">
        <div class="card-header bg-info text-white">
            <h5 class="card-title mb-0">
                <span class="oi oi-clock me-2"></span>History
            </h5>
        </div>
        <div class="card-body p-0">
            @if (history != null && history.Count > 0)
            {
                <div class="list-group list-group-flush">
                    @foreach (var item in history)
                    {
                        <div class="list-group-item d-flex justify-content-between align-items-center">
                            <button type="button" 
                                class="btn btn-link text-start text-decoration-none flex-grow-1" 
                                @onclick="() => LoadFromHistory(item.InputText)">
                                <div>
                                    <div class="text-truncate fw-bold" title="@item.InputText">@item.InputText</div>
                                    <small class="text-muted">@FormatTime(item.Timestamp)</small>
                                </div>
                            </button>
                            <button type="button" 
                                class="btn btn-sm btn-close" 
                                @onclick="() => RemoveHistoryAsync(item.Id)"
                                title="Delete this history item"></button>
                        </div>
                    }
                </div>
                <div class="p-3 border-top">
                    <button class="btn btn-sm btn-outline-danger w-100" @onclick="ClearHistoryAsync">
                        <span class="oi oi-trash me-2"></span>Clear All
                    </button>
                </div>
            }
            else
            {
                <div class="p-3 text-center text-muted">
                    <p class="mb-0">No history yet</p>
                </div>
            }
        </div>
    </div>
</div>

@code {
    private string inputText = "你好，世界！";
    private List<RubyToken>? rubyTokens;
    private List<ConversionItem>? history;
    private int selectedIndex = -1;
    private ElementReference previewBox;
    private string rubyMode = "pinyin";

    private record LineToken(int Index, RubyToken Token);

    private List<List<LineToken>> GetTokenLines()
    {
        var lines = new List<List<LineToken>>();
        if (rubyTokens == null) return lines;

        var currentLine = new List<LineToken>();

        for (int i = 0; i < rubyTokens.Count; i++)
        {
            var token = rubyTokens[i];
            if (!token.IsRuby && token.Text != null && (token.Text.Contains('\n') || token.Text.Contains('\r')))
            {
                var parts = token.Text.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
                for (int j = 0; j < parts.Length; j++)
                {
                    if (parts[j].Length > 0)
                    {
                        currentLine.Add(new LineToken(i, new RubyToken { Text = parts[j], IsRuby = false }));
                    }
                    if (j < parts.Length - 1)
                    {
                        lines.Add(currentLine);
                        currentLine = new List<LineToken>();
                    }
                }
            }
            else
            {
                currentLine.Add(new LineToken(i, token));
            }
        }

        if (currentLine.Count > 0 || lines.Count == 0)
        {
            lines.Add(currentLine);
        }

        return lines;
    }

    protected override async Task OnInitializedAsync()
    {
        await HistoryService.InitializeAsync();
        await LoadHistory();
    }

    private async Task LoadHistory()
    {
        history = await HistoryService.GetHistoryAsync();
    }

    private void ConvertText()
    {
        if (!string.IsNullOrWhiteSpace(inputText))
        {
            rubyTokens = PinyinService.GetPinyin(inputText);
            selectedIndex = -1;
            
            _ = AddToHistory();
        }
    }

    private async Task AddToHistory()
    {
        await HistoryService.AddToHistoryAsync(inputText);
        await LoadHistory();
    }

    private void LoadFromHistory(string text)
    {
        inputText = text;
        ConvertText();
    }

    private async Task RemoveHistoryAsync(int id)
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Delete this history item?");
        if (confirmed)
        {
            await HistoryService.RemoveFromHistoryAsync(id);
            await LoadHistory();
        }
    }

    private async Task ClearHistoryAsync()
    {
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Clear all history? This cannot be undone.");
        if (confirmed)
        {
            await HistoryService.ClearHistoryAsync();
            await LoadHistory();
        }
    }

    private void ChangeMode(ChangeEventArgs e)
    {
        rubyMode = e.Value?.ToString() ?? "pinyin";
    }

    private void SelectToken(int index)
    {
        selectedIndex = index;
    }

    private string GetClass(int index)
    {
        return index == selectedIndex ? "ruby-text selected" : "ruby-text";
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (rubyTokens == null || rubyTokens.Count == 0) return;

        if (e.Key == "ArrowRight" || e.Key == "." || e.Key == ">")
        {
            MoveSelection(1);
        }
        else if (e.Key == "ArrowLeft" || e.Key == "," || e.Key == "<")
        {
            MoveSelection(-1);
        }
        else if (e.Key == "ArrowDown")
        {
            MoveToPhrase(1);
        }
        else if (e.Key == "ArrowUp")
        {
            MoveToPhrase(-1);
        }
    }

    private void MoveSelection(int direction)
    {
        if (rubyTokens == null) return;
        
        int newIndex = selectedIndex;
        
        while (true)
        {
            newIndex += direction;
            if (newIndex < 0 || newIndex >= rubyTokens.Count) break;

            if (rubyTokens[newIndex].IsRuby)
            {
                selectedIndex = newIndex;
                break;
            }
        }
    }

    private void MoveToPhrase(int direction)
    {
        if (rubyTokens == null) return;

        int newIndex = selectedIndex;

        while (true)
        {
            newIndex += direction;
            if (newIndex < 0 || newIndex >= rubyTokens.Count) break;

            if (IsPhraseStart(newIndex))
            {
                selectedIndex = newIndex;
                break;
            }
        }
    }

    private bool IsPhraseStart(int index)
    {
        if (rubyTokens == null || index < 0 || index >= rubyTokens.Count) return false;
        
        if (!rubyTokens[index].IsRuby) return false;

        if (index == 0) return true;

        var prevToken = rubyTokens[index - 1];
        if (prevToken.IsRuby) return false;

        string text = prevToken.Text ?? "";
        
        if (text.Contains("。") || text.Contains("！") || text.Contains("？") || 
            text.Contains("!") || text.Contains("?") || text.Contains(".") || 
            text.Contains("\n") || text.Contains("\r") ||
            text.Contains("，") || text.Contains(",") || text.Contains("、") ||
            text.Contains("；") || text.Contains(";") || text.Contains("：") || text.Contains(":"))
        {
            return true;
        }

        return false;
    }

    private string FormatTime(DateTime dt)
    {
        var now = DateTime.Now;
        var diff = now - dt;

        if (diff.TotalSeconds < 60)
            return "Just now";
        if (diff.TotalMinutes < 60)
            return $"{(int)diff.TotalMinutes}m ago";
        if (diff.TotalHours < 24)
            return $"{(int)diff.TotalHours}h ago";
        if (diff.TotalDays < 7)
            return $"{(int)diff.TotalDays}d ago";
        
        return dt.ToString("MMM d");
    }
}

